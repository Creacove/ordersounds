
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from 'sonner';
import { CACHE_KEYS, updateNetworkConditions, loadFromCache } from '@/utils/beatsCacheUtils';

const SUPABASE_URL = "https://uoezlwkxhbzajdivrlby.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVvZXpsd2t4aGJ6YWpkaXZybGJ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI3Mzg5MzAsImV4cCI6MjA1ODMxNDkzMH0.TwIkGiLNiuxTdzbAxv6zBgbK1zIeNkhZ6qeX6OmhWOk";

// Track ongoing request URLs to prevent duplicate requests
const ongoingRequests = new Map();

// Enhanced fetch with deduplication and extended timeouts - NO RETRIES
const enhancedFetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
  const url = typeof input === 'string' ? input : input.url;
  const method = init?.method || 'GET';
  
  // Create a unique key for this request
  const requestKey = `${method}:${url}:${JSON.stringify(init?.body || '')}`;
  
  // Check if this exact request is already in progress
  if (ongoingRequests.has(requestKey)) {
    console.log(`Duplicate request prevented: ${requestKey}`);
    try {
      // Return the existing promise to avoid duplicate requests
      return await ongoingRequests.get(requestKey);
    } catch (err) {
      // If the ongoing request fails, we'll proceed with a new one
      ongoingRequests.delete(requestKey);
      console.log(`Previous request failed, proceeding with new request: ${requestKey}`);
    }
  }
  
  // Create the fetch promise - NO RETRIES
  const fetchPromise = (async () => {
    try {
      const startTime = Date.now();
      
      // Set extended timeout (30 seconds for all requests to ensure completion)
      const timeoutDuration = 30000; // 30 seconds fixed timeout
      
      // Create a timeout promise
      const timeoutPromise = new Promise<Response>((_, reject) => {
        setTimeout(() => {
          reject(new Error(`Request timeout after ${timeoutDuration}ms`));
        }, timeoutDuration);
      });
      
      // Race the fetch against the timeout
      const response = await Promise.race([
        fetch(input, init),
        timeoutPromise
      ]);
      
      const endTime = Date.now();
      const responseTime = endTime - startTime;
      
      // Track response time for network conditions assessment
      updateNetworkMetrics(responseTime);
      
      return response;
    } catch (err) {
      // No retries, just throw the error to be handled by the caller
      throw err;
    }
  })();
  
  // Store the promise in the ongoing requests map
  ongoingRequests.set(requestKey, fetchPromise);
  
  try {
    const response = await fetchPromise;
    return response;
  } finally {
    // Clean up the map after the request is complete
    ongoingRequests.delete(requestKey);
  }
};

// Simplified network metrics tracking
const updateNetworkMetrics = (responseTimeMs: number): void => {
  try {
    // Update network conditions classification
    updateNetworkConditions(responseTimeMs);
    
    // Store last response time for future reference
    localStorage.setItem('last_response_time', responseTimeMs.toString());
    localStorage.setItem('last_response_timestamp', Date.now().toString());
  } catch (error) {
    console.error('Error updating network metrics:', error);
  }
};

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storage: typeof window !== 'undefined' ? localStorage : undefined,
    detectSessionInUrl: true,
    flowType: 'pkce'
  },
  global: {
    headers: {
      'Content-Type': 'application/json',
      'X-Client-Info': 'lovable-beats-app'
    },
    fetch: enhancedFetch
  },
  db: {
    schema: 'public'
  },
  realtime: {
    params: {
      eventsPerSecond: 0.5  // Reduced to 0.5 events per second to minimize realtime connections
    }
  }
});

// Simplified connection check with caching to avoid redundant checks
let connectionCheckInProgress = false;
let lastConnectionCheck = 0;
const CONNECTION_CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes

export const checkSupabaseConnection = async (): Promise<boolean> => {
  // Check if we've done this recently or if it's already in progress
  const now = Date.now();
  if (connectionCheckInProgress || (now - lastConnectionCheck < CONNECTION_CHECK_INTERVAL)) {
    // Return cached result if we checked within the interval
    const cachedResult = localStorage.getItem('supabase_connection_status');
    return cachedResult === 'connected';
  }
  
  connectionCheckInProgress = true;
  
  try {
    // Try to get from cache first
    const cachedBeats = loadFromCache(CACHE_KEYS.ALL_BEATS);
    
    if (cachedBeats) {
      // If we have cached data, do a lighter health check
      const { data, error } = await supabase.from('beats').select('id').limit(1).maybeSingle();
      const isConnected = !error;
      
      // Store connection status and update last check time
      localStorage.setItem('supabase_connection_status', isConnected ? 'connected' : 'disconnected');
      lastConnectionCheck = now;
      
      return isConnected;
    } else {
      // For first load, we need a more thorough check
      const { data, error } = await supabase.from('beats').select('id').limit(1).maybeSingle();
      
      const isConnected = !error;
      localStorage.setItem('supabase_connection_status', isConnected ? 'connected' : 'disconnected');
      lastConnectionCheck = now;
      
      return isConnected;
    }
  } catch (e) {
    console.error('Supabase connection check failed:', e);
    localStorage.setItem('supabase_connection_status', 'disconnected');
    return false;
  } finally {
    connectionCheckInProgress = false;
  }
};
