// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from 'sonner';

const SUPABASE_URL = "https://uoezlwkxhbzajdivrlby.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVvZXpsd2t4aGJ6YWpkaXZybGJ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI3Mzg5MzAsImV4cCI6MjA1ODMxNDkzMH0.TwIkGiLNiuxTdzbAxv6zBgbK1zIeNkhZ6qeX6OmhWOk";

// Enhanced fetch with retry logic
const enhancedFetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
  const maxRetries = 3;
  const baseDelay = 1000; // 1 second initial delay
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const startTime = Date.now();
      const response = await fetch(input, init);
      const endTime = Date.now();
      
      // Track response time for adaptive timeout calculation
      if (typeof window !== 'undefined' && window.localStorage) {
        try {
          const responseTime = endTime - startTime;
          const networkTimesRaw = localStorage.getItem('network_response_times') || '[]';
          const networkTimes = JSON.parse(networkTimesRaw);
          networkTimes.push(responseTime);
          
          // Keep only last 10 response times
          if (networkTimes.length > 10) {
            networkTimes.shift();
          }
          
          localStorage.setItem('network_response_times', JSON.stringify(networkTimes));
        } catch (e) {
          console.error('Error tracking network performance:', e);
        }
      }
      
      return response;
    } catch (err) {
      console.warn(`Fetch attempt ${attempt + 1} failed:`, err);
      
      if (attempt === maxRetries) {
        throw err; // Retries exhausted, propagate the error
      }
      
      // Exponential backoff with jitter
      const delay = baseDelay * Math.pow(2, attempt) * (0.5 + Math.random() * 0.5);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  // This should never be reached because the last iteration will either return or throw
  throw new Error('Unexpected fetch retry logic failure');
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storage: typeof window !== 'undefined' ? localStorage : undefined,
    detectSessionInUrl: true, // Ensure OAuth redirect handling works
    flowType: 'pkce', // Use PKCE flow for more secure OAuth
    debug: process.env.NODE_ENV === 'development' // Enable debug in development
  },
  global: {
    headers: {
      'Content-Type': 'application/json'
    },
    fetch: enhancedFetch
  },
  db: {
    schema: 'public'
  },
  realtime: {
    params: {
      eventsPerSecond: 2 // Lower realtime event rate for better performance
    }
  }
});

// Export a function to check API health
export const checkSupabaseConnection = async (): Promise<boolean> => {
  try {
    const start = Date.now();
    const { data, error } = await supabase.from('beats').select('id').limit(1).maybeSingle();
    const end = Date.now();
    
    // Store response time for adaptive timeout adjustment
    const responseTime = end - start;
    if (typeof window !== 'undefined') {
      try {
        if (responseTime > 10000) {
          toast.warning("Network connection is slow. App may take longer to load.", {
            duration: 5000,
            id: "network-slow"
          });
        }
      } catch (e) {
        console.error('Error tracking network metrics:', e);
      }
    }
    
    return !error;
  } catch (e) {
    console.error('Supabase connection check failed:', e);
    return false;
  }
};
