// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from 'sonner';
import { CACHE_KEYS, updateNetworkConditions, loadFromCache } from '@/utils/beatsCacheUtils';

const SUPABASE_URL = "https://uoezlwkxhbzajdivrlby.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVvZXpsd2t4aGJ6YWpkaXZybGJ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI3Mzg5MzAsImV4cCI6MjA1ODMxNDkzMH0.TwIkGiLNiuxTdzbAxv6zBgbK1zIeNkhZ6qeX6OmhWOk";

// Track ongoing request URLs to prevent duplicate requests
const ongoingRequests = new Map();

// Enhanced fetch with single attempt, longer timeout, and deduplication
const enhancedFetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
  const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
  const method = init?.method || 'GET';
  
  // Create a unique key for this request
  const requestKey = `${method}:${url}:${JSON.stringify(init?.body || '')}`;
  
  // Check if this exact request is already in progress
  if (ongoingRequests.has(requestKey)) {
    try {
      // Return the existing promise to avoid duplicate requests
      return await ongoingRequests.get(requestKey);
    } catch (err) {
      // Clear the failed request from the map and continue with a new attempt
      ongoingRequests.delete(requestKey);
      console.warn('Previous request failed, making a fresh attempt');
    }
  }
  
  // Create the fetch promise with NO retries - only one attempt
  const fetchPromise = (async () => {
    try {
      const startTime = Date.now();
      
      // Set a much longer timeout for critical data fetches
      // This is especially important for the initial data load
      const timeoutDuration = getLongerTimeout(url);
      
      // Create a timeout promise
      const timeoutPromise = new Promise<Response>((_, reject) => {
        setTimeout(() => {
          reject(new Error(`Request timeout after ${timeoutDuration}ms`));
        }, timeoutDuration);
      });
      
      // Race the fetch against the timeout
      const response = await Promise.race([
        fetch(input, init),
        timeoutPromise
      ]);
      
      const endTime = Date.now();
      const responseTime = endTime - startTime;
      
      // Track response time for future reference
      updateNetworkMetrics(responseTime);
      
      if (response.status >= 500) {
        throw new Error(`Server error: ${response.status}`);
      }
      
      return response;
    } catch (err) {
      // We don't retry - just throw the error for the caller to handle
      throw err;
    }
  })();
  
  // Store the promise in the ongoing requests map
  ongoingRequests.set(requestKey, fetchPromise);
  
  try {
    const response = await fetchPromise;
    return response;
  } finally {
    // Clean up the map after the request is complete
    ongoingRequests.delete(requestKey);
  }
};

// Use much longer timeouts for critical operations
const getLongerTimeout = (url: string): number => {
  // Significantly longer timeouts than before
  const baseTimeouts = {
    initial: 60000,    // 60s for initial data load
    standard: 45000,   // 45s for standard operations
    auth: 30000        // 30s for auth operations
  };
  
  // Prioritize based on endpoint importance
  if (url.includes('beats?select')) {
    // This is the critical data fetch that needs to succeed
    return baseTimeouts.initial;
  } else if (url.includes('auth')) {
    // Auth endpoints are critical, but typically faster
    return baseTimeouts.auth;
  }
  
  // Default to standard timeout for all other operations
  return baseTimeouts.standard;
};

// Track network performance metrics
const updateNetworkMetrics = (responseTimeMs: number): void => {
  try {
    // Update network conditions classification
    updateNetworkConditions(responseTimeMs);
    
    // Store last 3 response times (reduced from 5 to avoid excessive storage)
    const responseTimesRaw = localStorage.getItem('network_response_times') || '[]';
    const responseTimes = JSON.parse(responseTimesRaw);
    
    responseTimes.push(responseTimeMs);
    
    // Keep only the last 3 response times
    if (responseTimes.length > 3) {
      responseTimes.shift();
    }
    
    localStorage.setItem('network_response_times', JSON.stringify(responseTimes));
  } catch (error) {
    console.error('Error updating network metrics:', error);
  }
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storage: typeof window !== 'undefined' ? localStorage : undefined,
    detectSessionInUrl: true,
    flowType: 'pkce'
  },
  global: {
    headers: {
      'Content-Type': 'application/json',
      'X-Client-Info': 'lovable-beats-app'  // Add app identifier for debugging
    },
    fetch: enhancedFetch
  },
  db: {
    schema: 'public'
  },
  realtime: {
    params: {
      eventsPerSecond: 0.5  // Reduced from 1 to 0.5 to further limit realtime connections
    }
  }
});

// Implement request throttling to prevent API hammering
let connectionCheckInProgress = false;
let lastConnectionCheck = 0;

// Export a function to check API health with throttling
export const checkSupabaseConnection = async (): Promise<boolean> => {
  // Extended throttling: Check once every 5 minutes instead of every minute
  const now = Date.now();
  if (connectionCheckInProgress || (now - lastConnectionCheck < 300000)) { // 5 minutes
    // Return cached result if we checked within the last 5 minutes
    const cachedResult = localStorage.getItem('supabase_connection_status');
    return cachedResult === 'connected';
  }
  
  connectionCheckInProgress = true;
  
  try {
    // Try to get from cache first - always prefer cached data
    const cachedBeats = loadFromCache(CACHE_KEYS.ALL_BEATS);
    
    if (cachedBeats) {
      // If we have cached data, just assume we're online
      // and avoid making a network check at all
      localStorage.setItem('supabase_connection_status', 'connected');
      lastConnectionCheck = now;
      return true;
    } else {
      // Only for first load, we need to check if we can connect
      const { data, error } = await supabase.from('beats').select('id').limit(1).maybeSingle();
      
      const isConnected = !error;
      localStorage.setItem('supabase_connection_status', isConnected ? 'connected' : 'disconnected');
      lastConnectionCheck = now;
      
      return isConnected;
    }
  } catch (e) {
    console.error('Supabase connection check failed:', e);
    localStorage.setItem('supabase_connection_status', 'disconnected');
    return false;
  } finally {
    connectionCheckInProgress = false;
  }
};
